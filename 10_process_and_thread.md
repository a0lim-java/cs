## 10-1. 프로세스 개요
* 프로세스의 종류
  - 포그라운드 프로세스(foreground process)  
    : 사용자가 볼 수 있는 공간에서 실행되는 프로세스
  - 백그라운드 프로세스(background process)  
    : 사용자가 볼 수 없는 공간에서 실행되는 프로세스
    + 사용자와 직접 상호작용이 가능한 백그라운드 프로세스
    + 정해진 일만 수행하는 프로세스: 데몬(daemon)(= 서비스)(= service)
* 프로세스 제어 블록(PCB)  
  : 빠르게 번갈아 수행되는 프로세스들을 관리하는 자료구조
  - 프로세스 관련 정보를 저장하는 자료 구조
  - 프로세스 생성 시, 커널 영역에 생성. 종료 시 폐기
  - 대표적인 정보
    + 프로세스 ID(= PID): 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
    + 레지스터 값: 프로세스는 자신의 실행 차례가 오면, 이전까지 사용한 레지스터 중간 값을 모두 복원 후, 실행 재개하기 때문에 필요
    + 프로세스 상태: 대기상태, 실행상태 등
    + CPU 스케줄링 정보: 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
    + 메모리 정보: 프로세스가 어느 주소에 저장되어 있는지에 대한 정보, 페이지 테이블 정보
    + 사용한 파일과 입출력장치 정보: 할당된 입출력장치, 사용 중인(열린) 파일 정보
* 문맥 교환(context switch)  
  : 기존의 실행 중인 프로세스 문맥을 백업하고, 새로운 프로세스 실행을 위해 문맥을 복구하는 과정
  - 여러 프로세스가 끊임없이 빠르게 번갈아가며 실행되는 원리
  - 문맥  
    : 기존에 실행되던 프로세스의 지금까지의 중간 정보  
  ![image](https://github.com/a0lim-java/cs/assets/104348646/974e05bb-9213-4c28-9659-437229657434)
  ![image](https://github.com/a0lim-java/cs/assets/104348646/5ae579f3-abc9-443e-9c55-99807304152a)  
* 프로세스의 메모리 영역
  - 코드 영역(= 텍스트 영역)
    + 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    + 데이터가 아닌 CPU가 실행할 명령어가 담김 -> 쓰기가 금지됨(read-only)
  - 데이터 영역
    + 프로그램이 실행되는 동안 내내 유지할 데이터 저장
    + ex. 전역 변수
  - 힙 영역
    + 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
  - 스택 영역
    + 데이터가 일시적으로 저장되는 공간
    + ex. 매개 변수, 지역 변수  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/da3123d4-4a3f-47ec-bc6a-29823182bdf6)  

## 10-2. 프로세스 상태와 계층 구조
* 프로세스 상태
  - 생성 상태  
    : 이제 막 메모리에 적재되어 PCB를 할당받은 상태
    + 준비가 완료되었다면, 준비 상태로 넘어감
  - 준비 상태
    : CPU를 할당 받아 실행할 수 있지만 자신의 차례가 아니기므로 기다리는 상태
    + 자신의 차례가 된다면 실행 상태로 넘어감(디스패치)
  - 실행 상태
    : CPU를 할당받아 실행 중인 상태
    + 할당된 시간을 모두 사용 시(타이머 인터럽트 발생 시) 준비 상태로 넘어감
    + 실행 도중 입출력장치를 사용하면, 입출력 작업이 끝날 때까지 대기 상태로 넘어감
  - 대기 상태  
    : 프로세스가 실행 도중 입출력장치를 사용하는 경우
    + 입출력 작업이 CPU에 비해 느림 -> 대기 상태
    + 입출력 작업이 끝나면(입출력 완료 인터럽트를 받으면) 준비 상태로 넘어감
  - 종료 상태  
    : 프로세스가 종료된 상태
    + PCB, 프로세스의 메모리 영역 정리  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/649df70b-eed7-4a67-bfae-44b92ed77cc4)  
* 프로세스 계층 구조
  - 부모 프로세스: 새 프로세스를 생성한 프로세스
  - 자식 프로세스: 부모 프로세스에 의해 생성된 프로세스
  - 부모, 자식 프로세스는 각자 다른 PID를 가짐(일부 운영체제에서는 자식 프로세스 PIB에 부모 프로세스 PID를 명시하기도 함)  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/4bfb3c57-9803-42bf-930a-c48089ed52d1)  
* 프로세스 생성 기법
  - fork 시스템 호출
    : 자기 자신 프로세스의 복사본을 자식 프로세스로 생성하는 시스템 호출
    + 부모 프로세스의 자원 상속
  - exec 시스템 호출
    : 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출
    + 코드/데이터 영역은 실행할 프로그램으로 바뀌고, 나머지 영역은 초기화
      ![image](https://github.com/a0lim-java/cs/assets/104348646/ae26df52-de97-4cf4-987a-3e49d9437d17)  

## 10-3. 스레드
* 스레드(thread)
  : 프로세스를 구성하는 실행 흐름의 단위
  - 하나의 프로세스는 하나 이상의 스레드를 가질 수 있음  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/00f0a9ce-d6fd-40c6-8f99-d691afd3e6a7)  
  - 단일 스레스 프로세스와 멀티 스레드 프로세스  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/a76c044a-24c0-4509-9278-408307a1f791)  
  - 스레드의 구성 요소
    + 스레드 ID, 프로그램 카운터를 비롯한 레지스터 값, 스택 등(실행에 필요한 최소한의 정보)  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/068bcc57-c22e-45fa-9a67-510f6322ece3)  
  - 모든 스레드는 프로세스의 자원을 공유하면서 실행함
* 멀티 프로세스와 멀티 스레드
  - 프로세스를 fork하면 모든 자원이 복제되어 저장됨
  - cf) 쓰기 시 복사(copy on write): fork 직후 같은 프로세스를 통째로 메모리에 중복 저장하지 않으면서, 동시에 프로세스끼리 자원을 공유하지 않는 방법  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/de68ecc3-141f-4fd5-8f2b-9b9aa457351c)  
  - cf) 프로세스 간 통신(IPC): 프로세스 간에도 자원을 주고받음. 파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신
  - 스레드는 각기 다른 스레드 ID, 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지는 자원을 공유함  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/3caab763-7265-42a8-9cf1-f4ee1f4b1403)  
