## 4-1 ALU와 제어장치
* ALU  
  : 계산기  
  ![image](https://github.com/a0lim-java/cs/assets/104348646/d5e2c5ba-993e-4213-95fa-30f2adcfe70e)  
  -> 계산을 위해, 피연산자와 수행할 연산이 필요
  - 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호을 받아들임
  - 플래그  
    : 연산 결과에 대한 부가 정보  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/e7bd53c6-455a-4759-9759-a923230f21f6)
    ![image](https://github.com/a0lim-java/cs/assets/104348646/0cbbe064-6df8-4ffe-ab6b-5c022e6a5cfd)  
* 제어장치
  : 받아들이는 정보
  ![image](https://github.com/a0lim-java/cs/assets/104348646/8e1ce785-1c5c-471e-ab9f-c1ae66d91126)  
  - 클럭
    : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
    ![image](https://github.com/a0lim-java/cs/assets/104348646/0e122870-68f8-46f2-b4d6-86db388e70a1)
  - 받는 정보
    - 명령어 레지스터로부터 해석할 명령어를 받아들임
    - 플래그 레지스터로부터 플래그를 받아들임
    - 제어 버스로부터 제어 신호를 받아들임
  - 제어신호
    + 레지스터로 레지스터의 행동에 관해 지시함
    + ALU에 연산 수행을 지시함
    + 메모리에 일기/쓰기를 지시함
    + 입출력장치에 읽기/쓰기/테스트 등을 지시함
      
## 4-2 레지스터
* 레지스터  
  : CPU 내부의 작은 임시저장장치
  - 프로그램 속 명령어/데이터는 실행 전/후로 레지스터에 저장
  - 프로그램 카운터  
    : 메모리에서 가져와서 읽어들일 명령어의 주소를 저장
    + 명령어 포인터(Instruction Pointer)라는 CPU도 존재함
  - 명령어 레지스터
    : 해석할 명령어를 저장(방금 메모리에서 읽어 들이 명령어)
    + 제어장치가 이를 해석함
  - 메모리 주소 레지스터  
    : 메모리의 주소를 저장
    + CPU가 읽어 들이고자 하는 주소를 주소 버스롤 보낼 때 거치는 레지스터
  - 메모리 버퍼 레지스터  
    : 메모리와 주고 받은 값(데이터, 명령어)를 저장
    + CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터
  - 예시
    1. 프로그램 카운터에 처음 실행할 명령어의 주소(1000번지)를 저장
       ![image](https://github.com/a0lim-java/cs/assets/104348646/ff3ec349-c199-4cc2-9e0d-edd22631e376)  
    2. 주소 버스를 통해서 읽고자 하는 주소(1000번지)를 메모리 주소 레지스터에 복사
       ![image](https://github.com/a0lim-java/cs/assets/104348646/29628fa7-f48c-486a-ba66-865299d8d9ca)
    3. 메모리 읽기 신호와 함께 읽고 싶은 메모리 주소를 요청
       ![image](https://github.com/a0lim-java/cs/assets/104348646/1dfa20a6-1b98-488f-b63f-7b0699721b55)  
    4. 메모리 주소에 해당하는 데이터를 데이터 버스를 통해 메로리 버퍼 레지스터에 저장 + 프로그램 카운터에 그 다음으로 실행할 명령어의 주소(1001번지)를 저장  
       ![image](https://github.com/a0lim-java/cs/assets/104348646/24a33d04-5604-4a00-b5ab-99633687a85b)  
    5. 해석할 데이터(1101)를 명령어 레지스터에 저장  
       ![image](https://github.com/a0lim-java/cs/assets/104348646/031be0dd-5d9f-4d4c-bf6a-1c96497c406b)  
  - 플래그 레지스터  
    : 연산 결과 또는 CPU 상태에 대한 부가적인 정보
  - 범용 레지스터  
    : 다양하고 일반적인 상황에서 자유롭게 사용
  - 스택 포인터  
    : 스택의 꼭대기를 가리키는 레지스터(스택이 어디까지 차 있는지에 대한 표시)
    + 스택 주소 지정 방식: 스택과 스택 포인터를 이용한 주소 지정 방식
  - 베이스 레지스터  
    : 기준 주소를 저장하는 레지스터
    + 변위 주소 지정 방식: 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻는 방식  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/3cf11c33-2e85-4ca0-8cd9-85286bf7a6b5)  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/f7030dea-62a2-4611-9d49-638e7211441c)  
      * 상대 주소 지정 방식: 오퍼랜드 필드의 값(변위)와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식  
          ![image](https://github.com/a0lim-java/cs/assets/104348646/ed99af99-e275-43df-ab92-981924d2ab7b)  
          -> 3번지 이전의 값을 접근하라
      * 베이스 레지스터 주소 지정 방식: 오퍼랜드의 필드값(변위)와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식  
          ![image](https://github.com/a0lim-java/cs/assets/104348646/fb29fb18-ef1d-4036-8bad-f5386c1896eb)  

## 4-3 명령어 사이클과 인터럽트
* 명령어 사이클  
  : 프로그램 속 명령어들이 반복되며 실행하는 주기
  + 인출, 실행 사이클이 번갈아 가며 실행됨
  + 인출 사이클: 가장 먼저 CPU로 메모리를 가져옴
  + 실행 사이클: 실행
  + 간접 사이클: 메모리 접근이 추가로 더 필요한 경우 사용됨  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/b8f4931a-c409-4c9e-bf1f-e2532cbde6d2)  
* 인터럽트  
  - 동기 인터럽트(예외)  
    : CPU가 예기치 못한 상황을 접했을 때 발생  
    + ex. debug, 잘못된 코드 실행 등
    + 폴트
    + 트랩
    + 중단
    + 소프트웨어 인터럽트
  - 비동기 인터럽트(하드웨어 인터럽트)  
    : 주로 입출력장치에 의해 발생
    + 알림과 같은 역할
    + ex) 키보드 입력, 프린트 완료 등
    + 입출력 잡업 도중에도 효율적으로 명령어를 처리하기 위해 사용(입출력장치의 속도가 느리기 때문)
    + 하드웨어 인터럽트의 처리 순서
      1. 입출력장치는 CPU에 인터럽트 요청 신호를 보냄
      2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전, 항상 인터럽트 여부를 확인
      3. CPU는 인터럽트 요청을 확인하고, 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
      4. 인터럽트를 받아들일 수 있다면, CPU는 지금까지의 작업을 백업함
      5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
      6. 인터럽트 서비스 루틴 실행이 끝나면, 4에서 백업한 작업을 복구하여 실행
    + 인터럽트 플래그
      * 막을 수 없는 인터럽트(NMI: non maskable interrupt)는 인터럽트 플래그로 막을 수 없음
    + 인터럽트 벡터
      : 각각의 인터럽트를 구분하기 위한 정보
      * 인터럽트 서비스 루틴의 시작 주소를 가지고 있음
    + 인터럽트 서비스 루틴
      : 인터럽트가 발생했을 때 해당 인터럽트를 처리할 방법이 적힌 프로그램
      * 프로그램으로, 메모리에 저장됨  
        ![image](https://github.com/a0lim-java/cs/assets/104348646/3da1357d-c826-4065-838f-93bdd9230d8f)  
    + 인터럽트가 발생했을 때, 실행중인 프로그램을 스택 영역에 백업하고 이후에 복구함  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/692c3959-270a-4988-b317-3b840b20fd7a)  
  - 최종 명령어 사이클  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/7e727eb8-a056-4701-884a-0234d43451d9)  

















