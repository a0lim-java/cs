## 14-1. 연속 메모리 할당
* 연속 메모리 할당
  : 프로세스에 연속적인 메모리 공간을 할당  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/a66fdea0-9fd5-4344-942a-673d442fdff0)  
* 스와핑
  : 현재 사용되지 않는 프로세스들을 보조기억장치의 스왑 영역으로 쫓아내고, 빈 공간에 새 프로세스를 적재  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/af0c82d2-510a-4872-8757-cd61f01e4299)  
* 메모리 할당
  : 빈 공간이 여러 개 있는 경우, 어디에 적합시킬지를 판단해야 함
  - 최초 적합(first-fit)
    : 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다, 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
    + 검색 최소화, 빠른 할당
  - 최적 적합(best-fit)
    : 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당
  - 최악 적합(worst-fit)
    : 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당
* 외부 단편화(external fragmentation)
  : 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
  - 외부 단편화 해결  
    1. 메모리 압축(compaction)(= 메모리 조각 모음)  
    : 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
    + 프로세스를 적당히 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
    2. 가상 메모리 기법
    : 실행하고자 하는 프로그램을 일부만 메모리에 적재하여, 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술

## 14-2. 페이징을 통한 가상 메모리 관리
* 페이징
  : 프로세스를 일정 크기로 자르고, 이를 메모리에 불연속적으로 할당
  - 페이지(page)
    : 논리 주소 공간을 자르는 단위
  - 프레임(frame)
    : 물리 주소 공간을 자르는, 페이지와 동일한 일정한 단위  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/26b4a670-0ce7-4233-a422-1584fa40f459)  
  - 페이징에서의 스와핑
    + 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)
    + 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
    + 실행에 필요한 페이지들은 메모리로 스왑 인  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/0f9172b9-5cce-45f5-b8b5-0294c6db2a42)  
      => 프로세스를 실행하기 위해 모든 페이지가 적재될 필요 없다 (= 물리 메모리보다 큰 프로세스도 실행할 수 있다)
* 페이지 테이블
  : 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 하는 방법
  - 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/da4416ea-d995-4468-9ef7-adecc5a26850)  
  - 물리적으로는 분산되어있지만, CPU 입장에서 바라본 논리 주소는 연속적으로 보임
* 내부 단편화
  : 하나의 페이지 크기보다 작은 크기로 발생
  - 외부 단편화보다 낭비되는 메모리가 훨씬 더 적음
* PTBR(프로세스 테이블 베이스 레지스터)
  - 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/afe4887a-ed21-4e89-bcce-0c49e459627d)    
  - 단점: 메모리 접근 시간이 두 배임(페이지 테이블 접근 + 프레임 접근)
* TLB
  : 페이지 테이블의 일부를 가져와 저장하는 페이지 테이블의 캐시 메모리  
  ![image](https://github.com/a0lim-java/cs/assets/104348646/dd4b8319-23d0-4d16-a2c4-9528a10e7dcf)  
* 페이징에서의 주소 변환
  - 논리주소
    + 페이지 번호(page number)
    + 변위(offset)  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/03358212-2580-4772-82d3-ef999318f15b)
* 페이지 테이블 엔트리(PTE)
  : 페이지 테이블의 각각의 행
  - 유효 비트  
    : 현재 해당 페이지에 접근 가능한지 여부(메모리에 적재되었는지/스왑되었는지)
    + 페이지 폴트(page fault): 유효 비트가 0인 페이지에 접근하는 경우에 발생하는 인터럽트
  - 보호 비트
    : 페이지 보호 기능을 위해 존재하는 비트(읽기 전용/ 읽기쓰기 등)  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/b322439e-fc82-4d73-951b-f369efd83edb)  
  - 참조 비트
    : CPU가 이 페이지에 접근한 적 있는지 여부
  - 수정 비트(= dirty bit)
    : CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부(변경 여부)
    + 수정된 페이지는 스왑 아웃될 때,  보조기억장치에도 쓰기 작업을 거쳐야 함

## 14-3. 쓰기 시 복사와 계층적 페이징
* 쓰기 시 복사
  - cf) 이론적인 fork() -> 부모 프로세스가 적재된 별도의 공간에 자식 프로세스가 통째로 복제되어 적재(프로세스 생성 시간 지연, 메모리 낭비)
  - 자식 프로세스는 부모 프로세스와 동일한 프레임을 가리킴(메모리 절약)  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/20b29c56-a419-4e9a-83d6-e5910df3a234)
  - 쓰기 작업 수행시, 해당 페이지는 별도의 공간으로 복제  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/1941061e-e326-4f26-9489-32a953b176df)  
* 계층적 페이징(= 다단계 페이징)  
  : 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식
  - 페이지 테이블을 여러 페이지로 쪼개고, 이 페이지를 가리키는 페이지 테이블(Outer 페이지 테이블)을 두는 방식  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/f53f4ab7-3fc1-48c2-a080-fd743d4446d1)
  - 논리주소(이단계 페이징)  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/dc02883f-f7a9-474e-a4b2-532525284965)  

## 14-4. 페이지 교체와 프레임 할당
* 요구 페이징  
  : 처음부터 모든 페이지를 적재하지 않고, 필요한 페이지만을 메모리에 적재하는 기법
  - 해당 페이지가 현재 메모리에 없을 경우, 페이지 폴트 발생 -> 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정
* 페이지 교체 알고리즘
  : 당장 실행에 필요한 페이지만 적재하기 위해 어떤 적재된 페이지를 보조기억장치로 내보낼지 결정하는 알고리즘
  - 페이지 폴트가 적을수록 좋은 알고리즘
    + 페이지 참조열(page reference string): CPU가 참고하는 페이지들 중 연속된 페이지를 생략한 페이지열
  - FIFO 페이지 교체 알고리즘
    + 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/cd7e4631-dd08-4110-912b-12a13ecca3ac)
    + 단점: 프로그램 실행 내내 사용될 페이지가 존재
  - 2차 기회(second-chance) 페이지 교체 알고리즘
    + FIFO 페이지 교체 알고리즘의 파생 알고리즘
    + 참조 비트 1: CPU가 한 번 참조한 적이 있는 페이지 -> 한 번 더 기회를 줌(참조 비트를 0으로 초기화 후 적재 시간을 현재 시간으로 설정)0
    + 참조 비트 0: CPU가 참조한 적이 없는 페이지 -> 내쫓음
  - 최적 페이지 교체 알고리즘  
    : 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
    + CPU에 의해 참조되는 횟수를 고려  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/158c7b10-df5c-40d1-a6d7-07ea57f62f4a)
    + 구현 어려움(앞으로 오랫동안 사용되지 않을 페이지를 예측 어려움)
    + 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주
  - LRU(Least-Recently-Used) 페이지 교체 알고리즘  
    : 가장 오래 사용되지 않은 페이지 교체  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/64adbf8a-7619-4aaa-9b74-c45679aa5b3b)  
  - 기타 페이지 교체 알고리즘
    + LRU 페이지 교체 알고리즘의 파생 알고리즘
* 스래싱과 프레임 할당
  - 페이지 폴트가 자주 발생하는 이유
    + 나쁜 페이지 교체 알고리즘을 사용
    + 프로세스가 사용할 수 있는 프레임 자체가 적음
  - 스레싱
    : 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저하되는 문제  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/1ca190a3-5e8a-4f45-abe8-33d195be3812)  
    + 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지지는 않음
    + 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 이에 맞게 할당해야 함
  - 균등 할당(equal allocation)  
    : 모든 프로세스들에게 균등하게 프레임을 할당
    + 정적 할당 방식
  - 비례 할당(proportional allocation)  
    : 프로세스 크기에 비례하여 프레임 할당
    + 정적 할당 방식
  - 작업 집합 모델(working set model)  
    : CPU가 특정 시간동안 주로 참조한 페이지 개수만큼만 프레임을 할당
    + 작업 집합: 실행 중인 프로세스가 일정 시간동안 참조한 페이지의 집합
    + 빈번한 페이지 교체를 방지  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/e42f0833-9412-4125-8e53-f8da5461624b)  
  - 페이지 폴트 빈도
    + 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/a086a4a3-b78a-4101-82e2-1b3fae3fa4f5)
