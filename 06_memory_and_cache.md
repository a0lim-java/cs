## 6-1 RAM의 특징과 종류
* RAM
  : 휘발성 저장장치
  - cf) 보조기억장치: 비휘발성 저장장치
  - DRAM(Dynamic RAM)
    : 저장된 데이터가 동적으로 사라지는 RAM
    + 데이터 소멸을 막기 위해 주기적으로 재활성화(refresh) 필요
    + 일반적으로 사용됨(소비전력 낮음, 저렴함, 높은 집적도 -> 대용량 설계에 용이)
  - SRAM(Static RAM)
    : 저장된 데이터가 정적인(사라지지 않는) RAM
    + 일반적으로 DRAM보다 더 빠름
    + 캐시 메모리에 사용(대용량으로 설계할 필요 없지만 빨라야 하는 저장장치에 사용)  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/43eeda67-4296-4592-a7ea-d9f76e6ad1f8)  
  - SDRAM(Synchronous DRAM)
    : 클럭 신호와 동기화된 DRAM
  - DDR SDRAM(Double Data Rate SDRAM)
    : 대역폭이 두 배 넓은 SDRAM
    + 대역폭: 데이터를 주고받는 길이의 너비
    + DDR SDRAM2, 3, 4: 대역폭이 2, 4, 8배 넓음 SDRAM
    + 최근 가장 대중적으로 사용

## 6-2 메모리의 주소 공간  
![image](https://github.com/a0lim-java/cs/assets/104348646/04714de7-e78e-4167-8c32-321f114f1c97)  
* 메모리의 저장된 값들의 가변성
  - 새롭게 실행되는 프로그램은 새로 메모리에 적재
  - 실행이 끝난 프로그램은 메모리에서 삭제
  - 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소는 달라짐
* 물리 주소
  - 메모리 입장에서 바라본 주소
  - 정보가 실제로 저장된 하드웨어상의 주소
* 논리 주소
  - CPU와 실행 중인 프로그램 입장에서 바라본 주소
  - 실행 중인 프롤그램 각각에게 부여된 0번지부터 시작하는 주소
* 물리 주소와 논리 주소의 변환
  - 논리주소를 물리 주소로 변환하는 과정이 필요
  - MMU(메모리 관리 장치)라는 하드웨어에 의해 변환   
  - 논리주소와 베이스 레지스터 값을 더해서 변환  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/6802fd3d-96a7-4f03-924f-3a415dea08e3)
    + 프로그램 A의 베이스 레지스터 값 = 프로그램 A의 시작점
    + 논리 주소 = 프로그램의 시작점으로부터 떨어진 거리
  - 다른 프로그램의 영역을 침범하는 명령어는 불가능
    ![image](https://github.com/a0lim-java/cs/assets/104348646/601cabee-c7aa-4b5b-a463-bfd5199d878a)
    + 메모리 보호가 필요
* 한계 레지스터
  - 프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음
  - 논리주소의 최대 크기를 저장
  - 베이스 레지스터 값 <= 프로그램의 물리 주소 범위 < 베이스 레지스터 + 한계 레지스터 값
    ![image](https://github.com/a0lim-java/cs/assets/104348646/1574d84b-11f5-47e9-8d24-dff0ddfd1111)
    ![image](https://github.com/a0lim-java/cs/assets/104348646/6b4f5eec-058b-47a2-a80f-18aa08275f38)
    + 실행 중인 프로그램의 독립적인 실행 공간 확보
    + 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호

## 6-3 캐시 메모리
* 저장 장치 계층 구조(Memory Hierarchy)(= 메모리 계층구조)
  : 각기 다른 용량과 성능의 저장 장치들을 계층화하여 표현한 구조
  - CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다
  - 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다  
  ![image](https://github.com/a0lim-java/cs/assets/104348646/09b76dec-3d15-4ca1-a688-e6b902078144)  
* 캐시 메모리
  : CPU와 메모리 사이에 위치한, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장장치
  - CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위함
  - CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가져와서 사용
    ![image](https://github.com/a0lim-java/cs/assets/104348646/b7f4d953-8cdb-46f3-bb69-b74e8570ec98)  
* 계층적 캐시 메모리(L1-L2-L3 캐시)
  - 일반적으로 L1, L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 위치함
  - 속도 순서: L1 > L2 > L3  
  ![image](https://github.com/a0lim-java/cs/assets/104348646/b759431f-35df-40a3-b01e-780b1195044a)
  - 멀티코어 프로세서의 캐시 메모리
    + L1, L2 캐시가 두개씩 존재하며 각 캐시마다 정보를 공유함  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/09ee03ae-b8fb-4592-888a-5588ad24491f)  
    
  - 분리형 캐시
    + L1D: 데이터만 저장 / L1I: 명령어만 저장  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/ea2c372a-ccec-43a2-be76-6055d30b8fe4)
  - 최종 저장 장치 계층 구조  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/25415335-d520-4c7d-91ca-816416815f09)  
* 참조 지역성의 원리
  - CPU가 자주 사용할 법한 내용을 예측하여 캐시 메모리에 저장해야 함
  - 캐시 히트
    : 예측이 들어맞는 경우(CPU가 캐시 메모리에 저장된 값을 활용할 경우)
  - 캐시 미스
    : 예측이 틀린 경우(CPU가 메모리에 접근해야 하는 경우) -> 성능 하락
  - 캐시 적중률 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
  - 참조 지역성의 원리
    : CPU가 메모리에 접근할 때의 주된 경향
    + CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
    + CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다(공간 지역성)
