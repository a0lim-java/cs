## 8-1 장치 컨트롤러와 장치 드라이버
cf) 이번 장에서 언급하는 입출력장치는 보조기억장치도 포함함
* 입출력 장치의 어려움
  - 많은 종류 -> 장치마다 속도, 데이터 전송 형식 등도 다양함 -> 정보를 주고받는 방식을 규격화하기 어려움
  - CPU와 메모리의 데이터 전송률은 높음, but 입출력장치의 데이터 전송률은 낮음
    + 전송률(transfer rate): 데이터를 얼마나 빨리 교환할 수 있는지르 나타내는 지표
* 장치 컨트롤러
  : 컴퓨터 내부와 입출력 장치를 연결하는 하드웨어
  - CPU와 입출력장치 간의 통신 중개
  - 오류 검출
  - 데이터 버퍼링
    + 버퍼링
      :  전송률이 높은 장치와 낮은 자이 사이에 주고 받는 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법  
  ![image](https://github.com/a0lim-java/cs/assets/104348646/7a0a63c2-559e-436c-a046-fc0be55f2f11)  
* 장치 컨트롤러의 구조
  - 데이터 레지스터  
    : CPU와 입출력 장치 사이에 주고받을 데이터가 담기는 레지스터(버퍼)
    + RAM을 대신 사용하기도 함
  - 상태 레지스터
    : 상태 정보 저장
    + 입출력장치가 입출력 작업을 할 준비가 되었는지
    + 입출력 작업이 완료되었는지
    + 입출력장치에 오류는 없는지 등의 상태 정보
  - 제어 레지스터  
    : 입출력장치가 수행할 내용에 대한 제어 정보  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/a62b6f7a-9b11-4425-91e7-9e19524894b5)  
* 장치 드라이버
  : 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램
  - 입출력장치를 연결하기 위한 소프트웨어적인 통로
  - cf) 장치 컨트롤러: 하드웨어적인 통로

## 8-2 다양한 입출력 방법
* 입출력 방식
  - 프로그램 입출력
  - 인터럽트 기반 입출력
  - DMA 입출력  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/4ee0fe1a-87da-4efd-96eb-39af3f0781fc)
* 프로그램 입출력
  : 프로그램 속 명령어로 입출력장치를 제어하는 방법
  - 입출력 명령어로써 장치 컨트롤러와 상호작용함
  - ex. 메모리에 저장된 정보를 하드 디스크에 백업(= 하드 디스크에 새로운 정보를 씀)  
      1.CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령 내보내기  
         ![image](https://github.com/a0lim-java/cs/assets/104348646/95a36d63-cf9f-47c6-a099-4a3fc7f6e69b)  
      2.하드 디스크 컨트롤러는 하드 디스크 상태 확인 -> 상태 레지스터에 준비 완료 표시  
         ![image](https://github.com/a0lim-java/cs/assets/104348646/fd700862-0e69-4e3e-bc93-79bbf4a2ab5a)  
      3-1. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인  
      3-2. 하드 디스크가 준비되었다면, 백업할 메모리의 정보를 데이터 레지스터에 쓰기  
      3-3. 아직 쓰기 작업이 끝나지 않았다면, 1번부터 반복. 끝났다면, 작업 종료  
         ![image](https://github.com/a0lim-java/cs/assets/104348646/122334e0-79e6-455a-abf5-2b6a30265fd0)  
  - 프로그램 입출력 방식
    + 메모리 맵 입출력
      : 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
      ![image](https://github.com/a0lim-java/cs/assets/104348646/e6716523-36f7-4a19-8518-92ad33d13158)  
      + 메모리 접근 명령어 = 입출력장치 접근 명령어
    + 고립형 입출력
      : 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법
      ![image](https://github.com/a0lim-java/cs/assets/104348646/5265c2b5-11f9-487b-aff1-f44263ceb071)
      + 입출력 전용 명령어 사용(입출력 읽기/쓰기 선을 활성화시킴)
* 인터럽트 기반 입출력
  - 하드웨어 인터럽트: 장치 컨트롤러에 의해 발생됨
    ![image](https://github.com/a0lim-java/cs/assets/104348646/28793db3-c0f0-414b-8cb9-07f5a9618ba3)  
  - 동시다발적인 인터럽트
    + 순차적으로 처리하는 방법
      : 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우
      + 우선 순위가 높은 인터럽트를 반영하지 못함  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/8080d740-d498-4067-be35-d80ca5487093)  
    + 우선순위를 반영한 인터럽트
      : NMI가 발생한 경우, 플래그 레지스터 속 인터럽트 비트를 활성화한 채 인터럽트를 처리하는 경우
      ![image](https://github.com/a0lim-java/cs/assets/104348646/1d38b74b-efde-4568-91ee-bac316bf92ce)  
      + PIC(Programmable Interrupt Controller)
         - 여러 장치 컨트롤러에 연결되어, 장치 컨트롤러의 하드웨어 인터럽트의 우선순위를 판단한 뒤, CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어
         - NMI 우선순위까지 판단하지는 않음
           ![image](https://github.com/a0lim-java/cs/assets/104348646/724ec654-e943-4dde-b93d-f65d078b5cef)  
* DMA 입출력(Direct Memory Access)
  : CPU를 거치지 않고 입출력장치가 메모리에 직접적으로 접근하는 기능
  - cf) 프로그램 입출력, 인터럽트 기반 입출력: CPU가 주도하고, 데이터도 CPU를 거침
    + 단점: CPU의 업무 과중
    ![image](https://github.com/a0lim-java/cs/assets/104348646/12245d4b-6895-4f05-b036-8968b714ab9a)
  - 과정
    1. CPU는 DMA 컨트롤러에 입출력 작업을 명령
    2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
    3. 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에 작업이 끝났음을 알림
    + DMA 컨트롤러가 CPU의 역할을 대행
    + CPU는 입출력 작업의 시작과 끝만 관여함
    + 단, 시스템 버스는 동시 사용이 불가능함 -> Cycle Stealing
      1) CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스 이용
      2) CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스 이용
* 입출력 버스
  - 입출력 버스를 통해 시스템 버스의 빈도를 낮춤
    ![image](https://github.com/a0lim-java/cs/assets/104348646/bf4d3040-60b4-4e53-9be5-5383a8181d7d)
  - PCI 버스, PCI express(PCIe) 버스와 입출력 장치를 연결짓는 슬롯: 슬롯 -> 입출력 버스 -> 시스템 버스
