## 5-1 빠른 CPU를 위한 설계 기법
* CPU의 속도를 빠르게 하는 방법
  - 클럭의 속도를 높임
  - 코어 수를 늘림
  - 스레드 수를 늘림
    
* 클럭
    + 클럭의 속도: 헤르츠
    + 단점: 발열
* 코어
  : 명령어를 실행하는 부품
  ![image](https://github.com/a0lim-java/cs/assets/104348646/5d4d4517-dc94-49dc-8317-5900f23c4d20)  
  - 멀티코어 프로세서
    : 여러 개의 코어를 포함하고 있는 CPU  
* 스레드  
  : 실행 흐름의 단위
  - 소프트웨어적 스레드  
    : 하나의 프로그램에서 독립적으로 실행되는 단위  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/6b130a9d-553f-4663-947c-75c7008e601f)  
    + 1코어 1스레드 CPU도 여러 소프트웨어적 스레드를 만들 수 있음(병렬처리)
  - 하드웨어적 스레드(= 논리 프로세서)
    : 하나의 코어가 동시에 처리하는 명령어 단위  
    ![image](https://github.com/a0lim-java/cs/assets/104348646/80ad5647-39c7-40ed-8039-e249108f6af9)  
    +  레지스터 세트
      : 하나의 명령어를 실행하기 위해 꼭 필욯나 레지스터들  
      ![image](https://github.com/a0lim-java/cs/assets/104348646/c5752b3a-4beb-4a20-ab6f-03312c95c651)   

## 5-2 명령어 병렬 처리 기법
* 명령어 파이프라인
  1. 명령어 인출(Instruction Fetch)
  2. 명령어 해석(Instruction Decode)
  3. 명령어 실행(Execute Instruction)
  4. 결과 저장(Write Back)
  - 같은 단계가 겹치지만 않는다면 CPU는 각 단계를 동시에 실행 가능
    ![image](https://github.com/a0lim-java/cs/assets/104348646/1e8cd661-708f-4818-b876-e7922a9c0e26)  
  - 명령어 파이프라이닝
    : 동시에 여러 개의 명령어를 겹쳐 실행하는 기법
* 파이프라인 위험
  : 명령어 파이프라인이 성능 향상에 실패하는 경우
  - 데이터 위험
    : 명령어간의 의존성이 이유
    + ex. 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우
    ![image](https://github.com/a0lim-java/cs/assets/104348646/456dd9e1-6e1f-4394-98ea-b7fd0da4b87b)  
  - 제어 위험
    : 프로그램 카운터의 갑작스러운 변화
    + ex. JUMP, INTERRUPT 등
  - 구조적 위험
    : 서로 다른 명령어가 같은 CPU 부품(ALU, 레지스터)를 쓰려고 하는 경우
* 슈퍼 스칼라
  : CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
  - 오늘날의 멀티스레드 프로세서
  - 이론적으로, 파이프라인 개수에 비례해서 처리 속도 증가
  - 실제로는 파이프라인 위험도의 증가로 인해 비례해서 증가하지 않음
* 비순차적 명령어 처리(OOOE)  
  : 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법
  ![image](https://github.com/a0lim-java/cs/assets/104348646/17df1fa8-4e5b-4657-b66c-e3ee68f1feda)  

## 5-3 명령어 집합 구조, CISC와 RISC
* 명령어 집합 (구조)(= ISA)  
  : CPU가 이해할 수 있는 명령어들의 모음
  - CPU마다 이해할 수 있는 명령어가 다름 -> 명령어 해석 방식, 레지스터의 종류와 개수, 파이프라이닝의 용이성 등이 달라짐
* CISC(Complex Instruction Set Computer)
  : 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
  - ex. x86, x86-64
  - 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용
  - 장점
    + 다양하고 강력한 명령어를 활용
    + 상대적으로 적은 수의 명령어로도 프로그램 실행 가능
  - 단점
    + 명령어 파이프라이닝이 불리함(명령어의 크기와 실행되기까지의 시간이 일정하지 않음 -> 여러 클럭이 필요 / 대다수 복잡한 명령어는 사용 빈도가 낮음)
      ![image](https://github.com/a0lim-java/cs/assets/104348646/5955f538-d74e-45e0-985c-222dac9fc6f1)  

* RISC(Riduced Instruction Set Computer)
  : 명령어의 종류가 적고, 짧고 규격화된 명령어 사용
  - 장점
    + 명령어 파이프라인에 유리
    + 메모리 접근 최소화(load, store로 제한)
    + 레지스터를 적극 활용
  - 단점
    + 더 많은 명령어로 프로그램을 동작시킴











